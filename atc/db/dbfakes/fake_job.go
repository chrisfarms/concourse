// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
	"github.com/concourse/concourse/atc/db/lock"
)

type FakeJob struct {
	AcquireSchedulingLockStub        func(lager.Logger) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	BuildStub        func(string) (db.Build, bool, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		arg1 string
	}
	buildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	buildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	BuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	BuildsWithTimeStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsWithTimeMutex       sync.RWMutex
	buildsWithTimeArgsForCall []struct {
		arg1 db.Page
	}
	buildsWithTimeReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsWithTimeReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	ClearTaskCacheStub        func(string, string) (int64, error)
	clearTaskCacheMutex       sync.RWMutex
	clearTaskCacheArgsForCall []struct {
		arg1 string
		arg2 string
	}
	clearTaskCacheReturns struct {
		result1 int64
		result2 error
	}
	clearTaskCacheReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	ConfigStub        func() atc.JobConfig
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 atc.JobConfig
	}
	configReturnsOnCall map[int]struct {
		result1 atc.JobConfig
	}
	CreateBuildStub        func() (db.Build, error)
	createBuildMutex       sync.RWMutex
	createBuildArgsForCall []struct {
	}
	createBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	EnsurePendingBuildExistsStub        func() error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct {
	}
	ensurePendingBuildExistsReturns struct {
		result1 error
	}
	ensurePendingBuildExistsReturnsOnCall map[int]struct {
		result1 error
	}
	FinishedAndNextBuildStub        func() (db.Build, db.Build, error)
	finishedAndNextBuildMutex       sync.RWMutex
	finishedAndNextBuildArgsForCall []struct {
	}
	finishedAndNextBuildReturns struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}
	finishedAndNextBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}
	FirstLoggedBuildIDStub        func() int
	firstLoggedBuildIDMutex       sync.RWMutex
	firstLoggedBuildIDArgsForCall []struct {
	}
	firstLoggedBuildIDReturns struct {
		result1 int
	}
	firstLoggedBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	GetFullNextBuildInputsStub        func() ([]db.BuildInput, bool, error)
	getFullNextBuildInputsMutex       sync.RWMutex
	getFullNextBuildInputsArgsForCall []struct {
	}
	getFullNextBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	getFullNextBuildInputsReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	GetNextBuildInputsStub        func() ([]db.BuildInput, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct {
	}
	getNextBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 error
	}
	getNextBuildInputsReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 error
	}
	GetPendingBuildsStub        func() ([]db.Build, error)
	getPendingBuildsMutex       sync.RWMutex
	getPendingBuildsArgsForCall []struct {
	}
	getPendingBuildsReturns struct {
		result1 []db.Build
		result2 error
	}
	getPendingBuildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	HasNewInputsStub        func() bool
	hasNewInputsMutex       sync.RWMutex
	hasNewInputsArgsForCall []struct {
	}
	hasNewInputsReturns struct {
		result1 bool
	}
	hasNewInputsReturnsOnCall map[int]struct {
		result1 bool
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	LatestCompletedBuildIDStub        func() int
	latestCompletedBuildIDMutex       sync.RWMutex
	latestCompletedBuildIDArgsForCall []struct {
	}
	latestCompletedBuildIDReturns struct {
		result1 int
	}
	latestCompletedBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	NextBuildIDStub        func() int
	nextBuildIDMutex       sync.RWMutex
	nextBuildIDArgsForCall []struct {
	}
	nextBuildIDReturns struct {
		result1 int
	}
	nextBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
	}
	pauseReturns struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct {
	}
	pausedReturns struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	PipelineStub        func() (db.Pipeline, bool, error)
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct {
	}
	pipelineReturns struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct {
	}
	pipelineIDReturns struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct {
	}
	pipelineNameReturns struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct {
	}
	publicReturns struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RequestScheduleStub        func() error
	requestScheduleMutex       sync.RWMutex
	requestScheduleArgsForCall []struct {
	}
	requestScheduleReturns struct {
		result1 error
	}
	requestScheduleReturnsOnCall map[int]struct {
		result1 error
	}
	RerunBuildStub        func(db.Build) (db.Build, error)
	rerunBuildMutex       sync.RWMutex
	rerunBuildArgsForCall []struct {
		arg1 db.Build
	}
	rerunBuildReturns struct {
		result1 db.Build
		result2 error
	}
	rerunBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	SaveNextInputMappingStub        func(db.InputMapping, bool) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		arg1 db.InputMapping
		arg2 bool
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	saveNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	ScheduleBuildStub        func(db.Build) (bool, error)
	scheduleBuildMutex       sync.RWMutex
	scheduleBuildArgsForCall []struct {
		arg1 db.Build
	}
	scheduleBuildReturns struct {
		result1 bool
		result2 error
	}
	scheduleBuildReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ScheduleRequestedTimeStub        func() time.Time
	scheduleRequestedTimeMutex       sync.RWMutex
	scheduleRequestedTimeArgsForCall []struct {
	}
	scheduleRequestedTimeReturns struct {
		result1 time.Time
	}
	scheduleRequestedTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	SetHasNewInputsStub        func(bool) error
	setHasNewInputsMutex       sync.RWMutex
	setHasNewInputsArgsForCall []struct {
		arg1 bool
	}
	setHasNewInputsReturns struct {
		result1 error
	}
	setHasNewInputsReturnsOnCall map[int]struct {
		result1 error
	}
	TagsStub        func() []string
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 []string
	}
	tagsReturnsOnCall map[int]struct {
		result1 []string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	TransitionBuildIDStub        func() int
	transitionBuildIDMutex       sync.RWMutex
	transitionBuildIDArgsForCall []struct {
	}
	transitionBuildIDReturns struct {
		result1 int
	}
	transitionBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct {
	}
	unpauseReturns struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFirstLoggedBuildIDStub        func(int) error
	updateFirstLoggedBuildIDMutex       sync.RWMutex
	updateFirstLoggedBuildIDArgsForCall []struct {
		arg1 int
	}
	updateFirstLoggedBuildIDReturns struct {
		result1 error
	}
	updateFirstLoggedBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateLastScheduledStub        func(time.Time) error
	updateLastScheduledMutex       sync.RWMutex
	updateLastScheduledArgsForCall []struct {
		arg1 time.Time
	}
	updateLastScheduledReturns struct {
		result1 error
	}
	updateLastScheduledReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateLatestCompletedBuildIDStub        func(db.Tx, int) error
	updateLatestCompletedBuildIDMutex       sync.RWMutex
	updateLatestCompletedBuildIDArgsForCall []struct {
		arg1 db.Tx
		arg2 int
	}
	updateLatestCompletedBuildIDReturns struct {
		result1 error
	}
	updateLatestCompletedBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateNextBuildIDStub        func(db.Tx, interface{}) error
	updateNextBuildIDMutex       sync.RWMutex
	updateNextBuildIDArgsForCall []struct {
		arg1 db.Tx
		arg2 interface{}
	}
	updateNextBuildIDReturns struct {
		result1 error
	}
	updateNextBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateTransitionBuildIDStub        func(db.Tx, int) error
	updateTransitionBuildIDMutex       sync.RWMutex
	updateTransitionBuildIDArgsForCall []struct {
		arg1 db.Tx
		arg2 int
	}
	updateTransitionBuildIDReturns struct {
		result1 error
	}
	updateTransitionBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJob) AcquireSchedulingLock(arg1 lager.Logger) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireSchedulingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakeJob) AcquireSchedulingLockCalls(stub func(lager.Logger) (lock.Lock, bool, error)) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = stub
}

func (fake *FakeJob) AcquireSchedulingLockArgsForCall(i int) lager.Logger {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	argsForCall := fake.acquireSchedulingLockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) Build(arg1 string) (db.Build, bool, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Build", []interface{}{arg1})
	fake.buildMutex.Unlock()
	if fake.BuildStub != nil {
		return fake.BuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeJob) BuildCalls(stub func(string) (db.Build, bool, error)) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = stub
}

func (fake *FakeJob) BuildArgsForCall(i int) string {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	argsForCall := fake.buildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) BuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildReturnsOnCall(i int, result1 db.Build, result2 bool, result3 error) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 bool
			result3 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) Builds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeJob) BuildsCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakeJob) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildsWithTime(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsWithTimeMutex.Lock()
	ret, specificReturn := fake.buildsWithTimeReturnsOnCall[len(fake.buildsWithTimeArgsForCall)]
	fake.buildsWithTimeArgsForCall = append(fake.buildsWithTimeArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("BuildsWithTime", []interface{}{arg1})
	fake.buildsWithTimeMutex.Unlock()
	if fake.BuildsWithTimeStub != nil {
		return fake.BuildsWithTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsWithTimeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) BuildsWithTimeCallCount() int {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	return len(fake.buildsWithTimeArgsForCall)
}

func (fake *FakeJob) BuildsWithTimeCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = stub
}

func (fake *FakeJob) BuildsWithTimeArgsForCall(i int) db.Page {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	argsForCall := fake.buildsWithTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) BuildsWithTimeReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	fake.buildsWithTimeReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildsWithTimeReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	if fake.buildsWithTimeReturnsOnCall == nil {
		fake.buildsWithTimeReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsWithTimeReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) ClearTaskCache(arg1 string, arg2 string) (int64, error) {
	fake.clearTaskCacheMutex.Lock()
	ret, specificReturn := fake.clearTaskCacheReturnsOnCall[len(fake.clearTaskCacheArgsForCall)]
	fake.clearTaskCacheArgsForCall = append(fake.clearTaskCacheArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ClearTaskCache", []interface{}{arg1, arg2})
	fake.clearTaskCacheMutex.Unlock()
	if fake.ClearTaskCacheStub != nil {
		return fake.ClearTaskCacheStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.clearTaskCacheReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) ClearTaskCacheCallCount() int {
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	return len(fake.clearTaskCacheArgsForCall)
}

func (fake *FakeJob) ClearTaskCacheCalls(stub func(string, string) (int64, error)) {
	fake.clearTaskCacheMutex.Lock()
	defer fake.clearTaskCacheMutex.Unlock()
	fake.ClearTaskCacheStub = stub
}

func (fake *FakeJob) ClearTaskCacheArgsForCall(i int) (string, string) {
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	argsForCall := fake.clearTaskCacheArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJob) ClearTaskCacheReturns(result1 int64, result2 error) {
	fake.clearTaskCacheMutex.Lock()
	defer fake.clearTaskCacheMutex.Unlock()
	fake.ClearTaskCacheStub = nil
	fake.clearTaskCacheReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) ClearTaskCacheReturnsOnCall(i int, result1 int64, result2 error) {
	fake.clearTaskCacheMutex.Lock()
	defer fake.clearTaskCacheMutex.Unlock()
	fake.ClearTaskCacheStub = nil
	if fake.clearTaskCacheReturnsOnCall == nil {
		fake.clearTaskCacheReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.clearTaskCacheReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) Config() atc.JobConfig {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configReturns
	return fakeReturns.result1
}

func (fake *FakeJob) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeJob) ConfigCalls(stub func() atc.JobConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakeJob) ConfigReturns(result1 atc.JobConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.JobConfig
	}{result1}
}

func (fake *FakeJob) ConfigReturnsOnCall(i int, result1 atc.JobConfig) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.JobConfig
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.JobConfig
	}{result1}
}

func (fake *FakeJob) CreateBuild() (db.Build, error) {
	fake.createBuildMutex.Lock()
	ret, specificReturn := fake.createBuildReturnsOnCall[len(fake.createBuildArgsForCall)]
	fake.createBuildArgsForCall = append(fake.createBuildArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateBuild", []interface{}{})
	fake.createBuildMutex.Unlock()
	if fake.CreateBuildStub != nil {
		return fake.CreateBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) CreateBuildCallCount() int {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	return len(fake.createBuildArgsForCall)
}

func (fake *FakeJob) CreateBuildCalls(stub func() (db.Build, error)) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = stub
}

func (fake *FakeJob) CreateBuildReturns(result1 db.Build, result2 error) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = nil
	fake.createBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) CreateBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createBuildMutex.Lock()
	defer fake.createBuildMutex.Unlock()
	fake.CreateBuildStub = nil
	if fake.createBuildReturnsOnCall == nil {
		fake.createBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) EnsurePendingBuildExists() error {
	fake.ensurePendingBuildExistsMutex.Lock()
	ret, specificReturn := fake.ensurePendingBuildExistsReturnsOnCall[len(fake.ensurePendingBuildExistsArgsForCall)]
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct {
	}{})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ensurePendingBuildExistsReturns
	return fakeReturns.result1
}

func (fake *FakeJob) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakeJob) EnsurePendingBuildExistsCalls(stub func() error) {
	fake.ensurePendingBuildExistsMutex.Lock()
	defer fake.ensurePendingBuildExistsMutex.Unlock()
	fake.EnsurePendingBuildExistsStub = stub
}

func (fake *FakeJob) EnsurePendingBuildExistsReturns(result1 error) {
	fake.ensurePendingBuildExistsMutex.Lock()
	defer fake.ensurePendingBuildExistsMutex.Unlock()
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) EnsurePendingBuildExistsReturnsOnCall(i int, result1 error) {
	fake.ensurePendingBuildExistsMutex.Lock()
	defer fake.ensurePendingBuildExistsMutex.Unlock()
	fake.EnsurePendingBuildExistsStub = nil
	if fake.ensurePendingBuildExistsReturnsOnCall == nil {
		fake.ensurePendingBuildExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensurePendingBuildExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) FinishedAndNextBuild() (db.Build, db.Build, error) {
	fake.finishedAndNextBuildMutex.Lock()
	ret, specificReturn := fake.finishedAndNextBuildReturnsOnCall[len(fake.finishedAndNextBuildArgsForCall)]
	fake.finishedAndNextBuildArgsForCall = append(fake.finishedAndNextBuildArgsForCall, struct {
	}{})
	fake.recordInvocation("FinishedAndNextBuild", []interface{}{})
	fake.finishedAndNextBuildMutex.Unlock()
	if fake.FinishedAndNextBuildStub != nil {
		return fake.FinishedAndNextBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.finishedAndNextBuildReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) FinishedAndNextBuildCallCount() int {
	fake.finishedAndNextBuildMutex.RLock()
	defer fake.finishedAndNextBuildMutex.RUnlock()
	return len(fake.finishedAndNextBuildArgsForCall)
}

func (fake *FakeJob) FinishedAndNextBuildCalls(stub func() (db.Build, db.Build, error)) {
	fake.finishedAndNextBuildMutex.Lock()
	defer fake.finishedAndNextBuildMutex.Unlock()
	fake.FinishedAndNextBuildStub = stub
}

func (fake *FakeJob) FinishedAndNextBuildReturns(result1 db.Build, result2 db.Build, result3 error) {
	fake.finishedAndNextBuildMutex.Lock()
	defer fake.finishedAndNextBuildMutex.Unlock()
	fake.FinishedAndNextBuildStub = nil
	fake.finishedAndNextBuildReturns = struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) FinishedAndNextBuildReturnsOnCall(i int, result1 db.Build, result2 db.Build, result3 error) {
	fake.finishedAndNextBuildMutex.Lock()
	defer fake.finishedAndNextBuildMutex.Unlock()
	fake.FinishedAndNextBuildStub = nil
	if fake.finishedAndNextBuildReturnsOnCall == nil {
		fake.finishedAndNextBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 db.Build
			result3 error
		})
	}
	fake.finishedAndNextBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) FirstLoggedBuildID() int {
	fake.firstLoggedBuildIDMutex.Lock()
	ret, specificReturn := fake.firstLoggedBuildIDReturnsOnCall[len(fake.firstLoggedBuildIDArgsForCall)]
	fake.firstLoggedBuildIDArgsForCall = append(fake.firstLoggedBuildIDArgsForCall, struct {
	}{})
	fake.recordInvocation("FirstLoggedBuildID", []interface{}{})
	fake.firstLoggedBuildIDMutex.Unlock()
	if fake.FirstLoggedBuildIDStub != nil {
		return fake.FirstLoggedBuildIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.firstLoggedBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) FirstLoggedBuildIDCallCount() int {
	fake.firstLoggedBuildIDMutex.RLock()
	defer fake.firstLoggedBuildIDMutex.RUnlock()
	return len(fake.firstLoggedBuildIDArgsForCall)
}

func (fake *FakeJob) FirstLoggedBuildIDCalls(stub func() int) {
	fake.firstLoggedBuildIDMutex.Lock()
	defer fake.firstLoggedBuildIDMutex.Unlock()
	fake.FirstLoggedBuildIDStub = stub
}

func (fake *FakeJob) FirstLoggedBuildIDReturns(result1 int) {
	fake.firstLoggedBuildIDMutex.Lock()
	defer fake.firstLoggedBuildIDMutex.Unlock()
	fake.FirstLoggedBuildIDStub = nil
	fake.firstLoggedBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) FirstLoggedBuildIDReturnsOnCall(i int, result1 int) {
	fake.firstLoggedBuildIDMutex.Lock()
	defer fake.firstLoggedBuildIDMutex.Unlock()
	fake.FirstLoggedBuildIDStub = nil
	if fake.firstLoggedBuildIDReturnsOnCall == nil {
		fake.firstLoggedBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.firstLoggedBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) GetFullNextBuildInputs() ([]db.BuildInput, bool, error) {
	fake.getFullNextBuildInputsMutex.Lock()
	ret, specificReturn := fake.getFullNextBuildInputsReturnsOnCall[len(fake.getFullNextBuildInputsArgsForCall)]
	fake.getFullNextBuildInputsArgsForCall = append(fake.getFullNextBuildInputsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetFullNextBuildInputs", []interface{}{})
	fake.getFullNextBuildInputsMutex.Unlock()
	if fake.GetFullNextBuildInputsStub != nil {
		return fake.GetFullNextBuildInputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getFullNextBuildInputsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) GetFullNextBuildInputsCallCount() int {
	fake.getFullNextBuildInputsMutex.RLock()
	defer fake.getFullNextBuildInputsMutex.RUnlock()
	return len(fake.getFullNextBuildInputsArgsForCall)
}

func (fake *FakeJob) GetFullNextBuildInputsCalls(stub func() ([]db.BuildInput, bool, error)) {
	fake.getFullNextBuildInputsMutex.Lock()
	defer fake.getFullNextBuildInputsMutex.Unlock()
	fake.GetFullNextBuildInputsStub = stub
}

func (fake *FakeJob) GetFullNextBuildInputsReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.getFullNextBuildInputsMutex.Lock()
	defer fake.getFullNextBuildInputsMutex.Unlock()
	fake.GetFullNextBuildInputsStub = nil
	fake.getFullNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) GetFullNextBuildInputsReturnsOnCall(i int, result1 []db.BuildInput, result2 bool, result3 error) {
	fake.getFullNextBuildInputsMutex.Lock()
	defer fake.getFullNextBuildInputsMutex.Unlock()
	fake.GetFullNextBuildInputsStub = nil
	if fake.getFullNextBuildInputsReturnsOnCall == nil {
		fake.getFullNextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.getFullNextBuildInputsReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) GetNextBuildInputs() ([]db.BuildInput, error) {
	fake.getNextBuildInputsMutex.Lock()
	ret, specificReturn := fake.getNextBuildInputsReturnsOnCall[len(fake.getNextBuildInputsArgsForCall)]
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getNextBuildInputsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakeJob) GetNextBuildInputsCalls(stub func() ([]db.BuildInput, error)) {
	fake.getNextBuildInputsMutex.Lock()
	defer fake.getNextBuildInputsMutex.Unlock()
	fake.GetNextBuildInputsStub = stub
}

func (fake *FakeJob) GetNextBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.getNextBuildInputsMutex.Lock()
	defer fake.getNextBuildInputsMutex.Unlock()
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) GetNextBuildInputsReturnsOnCall(i int, result1 []db.BuildInput, result2 error) {
	fake.getNextBuildInputsMutex.Lock()
	defer fake.getNextBuildInputsMutex.Unlock()
	fake.GetNextBuildInputsStub = nil
	if fake.getNextBuildInputsReturnsOnCall == nil {
		fake.getNextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 error
		})
	}
	fake.getNextBuildInputsReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) GetPendingBuilds() ([]db.Build, error) {
	fake.getPendingBuildsMutex.Lock()
	ret, specificReturn := fake.getPendingBuildsReturnsOnCall[len(fake.getPendingBuildsArgsForCall)]
	fake.getPendingBuildsArgsForCall = append(fake.getPendingBuildsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetPendingBuilds", []interface{}{})
	fake.getPendingBuildsMutex.Unlock()
	if fake.GetPendingBuildsStub != nil {
		return fake.GetPendingBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPendingBuildsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) GetPendingBuildsCallCount() int {
	fake.getPendingBuildsMutex.RLock()
	defer fake.getPendingBuildsMutex.RUnlock()
	return len(fake.getPendingBuildsArgsForCall)
}

func (fake *FakeJob) GetPendingBuildsCalls(stub func() ([]db.Build, error)) {
	fake.getPendingBuildsMutex.Lock()
	defer fake.getPendingBuildsMutex.Unlock()
	fake.GetPendingBuildsStub = stub
}

func (fake *FakeJob) GetPendingBuildsReturns(result1 []db.Build, result2 error) {
	fake.getPendingBuildsMutex.Lock()
	defer fake.getPendingBuildsMutex.Unlock()
	fake.GetPendingBuildsStub = nil
	fake.getPendingBuildsReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) GetPendingBuildsReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.getPendingBuildsMutex.Lock()
	defer fake.getPendingBuildsMutex.Unlock()
	fake.GetPendingBuildsStub = nil
	if fake.getPendingBuildsReturnsOnCall == nil {
		fake.getPendingBuildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getPendingBuildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) HasNewInputs() bool {
	fake.hasNewInputsMutex.Lock()
	ret, specificReturn := fake.hasNewInputsReturnsOnCall[len(fake.hasNewInputsArgsForCall)]
	fake.hasNewInputsArgsForCall = append(fake.hasNewInputsArgsForCall, struct {
	}{})
	fake.recordInvocation("HasNewInputs", []interface{}{})
	fake.hasNewInputsMutex.Unlock()
	if fake.HasNewInputsStub != nil {
		return fake.HasNewInputsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasNewInputsReturns
	return fakeReturns.result1
}

func (fake *FakeJob) HasNewInputsCallCount() int {
	fake.hasNewInputsMutex.RLock()
	defer fake.hasNewInputsMutex.RUnlock()
	return len(fake.hasNewInputsArgsForCall)
}

func (fake *FakeJob) HasNewInputsCalls(stub func() bool) {
	fake.hasNewInputsMutex.Lock()
	defer fake.hasNewInputsMutex.Unlock()
	fake.HasNewInputsStub = stub
}

func (fake *FakeJob) HasNewInputsReturns(result1 bool) {
	fake.hasNewInputsMutex.Lock()
	defer fake.hasNewInputsMutex.Unlock()
	fake.HasNewInputsStub = nil
	fake.hasNewInputsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) HasNewInputsReturnsOnCall(i int, result1 bool) {
	fake.hasNewInputsMutex.Lock()
	defer fake.hasNewInputsMutex.Unlock()
	fake.HasNewInputsStub = nil
	if fake.hasNewInputsReturnsOnCall == nil {
		fake.hasNewInputsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasNewInputsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeJob) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeJob) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) LatestCompletedBuildID() int {
	fake.latestCompletedBuildIDMutex.Lock()
	ret, specificReturn := fake.latestCompletedBuildIDReturnsOnCall[len(fake.latestCompletedBuildIDArgsForCall)]
	fake.latestCompletedBuildIDArgsForCall = append(fake.latestCompletedBuildIDArgsForCall, struct {
	}{})
	fake.recordInvocation("LatestCompletedBuildID", []interface{}{})
	fake.latestCompletedBuildIDMutex.Unlock()
	if fake.LatestCompletedBuildIDStub != nil {
		return fake.LatestCompletedBuildIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.latestCompletedBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) LatestCompletedBuildIDCallCount() int {
	fake.latestCompletedBuildIDMutex.RLock()
	defer fake.latestCompletedBuildIDMutex.RUnlock()
	return len(fake.latestCompletedBuildIDArgsForCall)
}

func (fake *FakeJob) LatestCompletedBuildIDCalls(stub func() int) {
	fake.latestCompletedBuildIDMutex.Lock()
	defer fake.latestCompletedBuildIDMutex.Unlock()
	fake.LatestCompletedBuildIDStub = stub
}

func (fake *FakeJob) LatestCompletedBuildIDReturns(result1 int) {
	fake.latestCompletedBuildIDMutex.Lock()
	defer fake.latestCompletedBuildIDMutex.Unlock()
	fake.LatestCompletedBuildIDStub = nil
	fake.latestCompletedBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) LatestCompletedBuildIDReturnsOnCall(i int, result1 int) {
	fake.latestCompletedBuildIDMutex.Lock()
	defer fake.latestCompletedBuildIDMutex.Unlock()
	fake.LatestCompletedBuildIDStub = nil
	if fake.latestCompletedBuildIDReturnsOnCall == nil {
		fake.latestCompletedBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.latestCompletedBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeJob) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeJob) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeJob) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) NextBuildID() int {
	fake.nextBuildIDMutex.Lock()
	ret, specificReturn := fake.nextBuildIDReturnsOnCall[len(fake.nextBuildIDArgsForCall)]
	fake.nextBuildIDArgsForCall = append(fake.nextBuildIDArgsForCall, struct {
	}{})
	fake.recordInvocation("NextBuildID", []interface{}{})
	fake.nextBuildIDMutex.Unlock()
	if fake.NextBuildIDStub != nil {
		return fake.NextBuildIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nextBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) NextBuildIDCallCount() int {
	fake.nextBuildIDMutex.RLock()
	defer fake.nextBuildIDMutex.RUnlock()
	return len(fake.nextBuildIDArgsForCall)
}

func (fake *FakeJob) NextBuildIDCalls(stub func() int) {
	fake.nextBuildIDMutex.Lock()
	defer fake.nextBuildIDMutex.Unlock()
	fake.NextBuildIDStub = stub
}

func (fake *FakeJob) NextBuildIDReturns(result1 int) {
	fake.nextBuildIDMutex.Lock()
	defer fake.nextBuildIDMutex.Unlock()
	fake.NextBuildIDStub = nil
	fake.nextBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) NextBuildIDReturnsOnCall(i int, result1 int) {
	fake.nextBuildIDMutex.Lock()
	defer fake.nextBuildIDMutex.Unlock()
	fake.NextBuildIDStub = nil
	if fake.nextBuildIDReturnsOnCall == nil {
		fake.nextBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nextBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pauseReturns
	return fakeReturns.result1
}

func (fake *FakeJob) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeJob) PauseCalls(stub func() error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = stub
}

func (fake *FakeJob) PauseReturns(result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) PauseReturnsOnCall(i int, result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct {
	}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pausedReturns
	return fakeReturns.result1
}

func (fake *FakeJob) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakeJob) PausedCalls(stub func() bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = stub
}

func (fake *FakeJob) PausedReturns(result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) PausedReturnsOnCall(i int, result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) Pipeline() (db.Pipeline, bool, error) {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct {
	}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pipelineReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeJob) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakeJob) PipelineCalls(stub func() (db.Pipeline, bool, error)) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = stub
}

func (fake *FakeJob) PipelineReturns(result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) PipelineReturnsOnCall(i int, result1 db.Pipeline, result2 bool, result3 error) {
	fake.pipelineMutex.Lock()
	defer fake.pipelineMutex.Unlock()
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if fake.PipelineIDStub != nil {
		return fake.PipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeJob) PipelineIDCalls(stub func() int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = stub
}

func (fake *FakeJob) PipelineIDReturns(result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.pipelineIDMutex.Lock()
	defer fake.pipelineIDMutex.Unlock()
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct {
	}{})
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if fake.PipelineNameStub != nil {
		return fake.PipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pipelineNameReturns
	return fakeReturns.result1
}

func (fake *FakeJob) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeJob) PipelineNameCalls(stub func() string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = stub
}

func (fake *FakeJob) PipelineNameReturns(result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.pipelineNameMutex.Lock()
	defer fake.pipelineNameMutex.Unlock()
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct {
	}{})
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if fake.PublicStub != nil {
		return fake.PublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicReturns
	return fakeReturns.result1
}

func (fake *FakeJob) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakeJob) PublicCalls(stub func() bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = stub
}

func (fake *FakeJob) PublicReturns(result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) PublicReturnsOnCall(i int, result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reloadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeJob) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeJob) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) RequestSchedule() error {
	fake.requestScheduleMutex.Lock()
	ret, specificReturn := fake.requestScheduleReturnsOnCall[len(fake.requestScheduleArgsForCall)]
	fake.requestScheduleArgsForCall = append(fake.requestScheduleArgsForCall, struct {
	}{})
	fake.recordInvocation("RequestSchedule", []interface{}{})
	fake.requestScheduleMutex.Unlock()
	if fake.RequestScheduleStub != nil {
		return fake.RequestScheduleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.requestScheduleReturns
	return fakeReturns.result1
}

func (fake *FakeJob) RequestScheduleCallCount() int {
	fake.requestScheduleMutex.RLock()
	defer fake.requestScheduleMutex.RUnlock()
	return len(fake.requestScheduleArgsForCall)
}

func (fake *FakeJob) RequestScheduleCalls(stub func() error) {
	fake.requestScheduleMutex.Lock()
	defer fake.requestScheduleMutex.Unlock()
	fake.RequestScheduleStub = stub
}

func (fake *FakeJob) RequestScheduleReturns(result1 error) {
	fake.requestScheduleMutex.Lock()
	defer fake.requestScheduleMutex.Unlock()
	fake.RequestScheduleStub = nil
	fake.requestScheduleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) RequestScheduleReturnsOnCall(i int, result1 error) {
	fake.requestScheduleMutex.Lock()
	defer fake.requestScheduleMutex.Unlock()
	fake.RequestScheduleStub = nil
	if fake.requestScheduleReturnsOnCall == nil {
		fake.requestScheduleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.requestScheduleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) RerunBuild(arg1 db.Build) (db.Build, error) {
	fake.rerunBuildMutex.Lock()
	ret, specificReturn := fake.rerunBuildReturnsOnCall[len(fake.rerunBuildArgsForCall)]
	fake.rerunBuildArgsForCall = append(fake.rerunBuildArgsForCall, struct {
		arg1 db.Build
	}{arg1})
	fake.recordInvocation("RerunBuild", []interface{}{arg1})
	fake.rerunBuildMutex.Unlock()
	if fake.RerunBuildStub != nil {
		return fake.RerunBuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rerunBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) RerunBuildCallCount() int {
	fake.rerunBuildMutex.RLock()
	defer fake.rerunBuildMutex.RUnlock()
	return len(fake.rerunBuildArgsForCall)
}

func (fake *FakeJob) RerunBuildCalls(stub func(db.Build) (db.Build, error)) {
	fake.rerunBuildMutex.Lock()
	defer fake.rerunBuildMutex.Unlock()
	fake.RerunBuildStub = stub
}

func (fake *FakeJob) RerunBuildArgsForCall(i int) db.Build {
	fake.rerunBuildMutex.RLock()
	defer fake.rerunBuildMutex.RUnlock()
	argsForCall := fake.rerunBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) RerunBuildReturns(result1 db.Build, result2 error) {
	fake.rerunBuildMutex.Lock()
	defer fake.rerunBuildMutex.Unlock()
	fake.RerunBuildStub = nil
	fake.rerunBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) RerunBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.rerunBuildMutex.Lock()
	defer fake.rerunBuildMutex.Unlock()
	fake.RerunBuildStub = nil
	if fake.rerunBuildReturnsOnCall == nil {
		fake.rerunBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.rerunBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) SaveNextInputMapping(arg1 db.InputMapping, arg2 bool) error {
	fake.saveNextInputMappingMutex.Lock()
	ret, specificReturn := fake.saveNextInputMappingReturnsOnCall[len(fake.saveNextInputMappingArgsForCall)]
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		arg1 db.InputMapping
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{arg1, arg2})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveNextInputMappingReturns
	return fakeReturns.result1
}

func (fake *FakeJob) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakeJob) SaveNextInputMappingCalls(stub func(db.InputMapping, bool) error) {
	fake.saveNextInputMappingMutex.Lock()
	defer fake.saveNextInputMappingMutex.Unlock()
	fake.SaveNextInputMappingStub = stub
}

func (fake *FakeJob) SaveNextInputMappingArgsForCall(i int) (db.InputMapping, bool) {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	argsForCall := fake.saveNextInputMappingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJob) SaveNextInputMappingReturns(result1 error) {
	fake.saveNextInputMappingMutex.Lock()
	defer fake.saveNextInputMappingMutex.Unlock()
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) SaveNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.saveNextInputMappingMutex.Lock()
	defer fake.saveNextInputMappingMutex.Unlock()
	fake.SaveNextInputMappingStub = nil
	if fake.saveNextInputMappingReturnsOnCall == nil {
		fake.saveNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) ScheduleBuild(arg1 db.Build) (bool, error) {
	fake.scheduleBuildMutex.Lock()
	ret, specificReturn := fake.scheduleBuildReturnsOnCall[len(fake.scheduleBuildArgsForCall)]
	fake.scheduleBuildArgsForCall = append(fake.scheduleBuildArgsForCall, struct {
		arg1 db.Build
	}{arg1})
	fake.recordInvocation("ScheduleBuild", []interface{}{arg1})
	fake.scheduleBuildMutex.Unlock()
	if fake.ScheduleBuildStub != nil {
		return fake.ScheduleBuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.scheduleBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeJob) ScheduleBuildCallCount() int {
	fake.scheduleBuildMutex.RLock()
	defer fake.scheduleBuildMutex.RUnlock()
	return len(fake.scheduleBuildArgsForCall)
}

func (fake *FakeJob) ScheduleBuildCalls(stub func(db.Build) (bool, error)) {
	fake.scheduleBuildMutex.Lock()
	defer fake.scheduleBuildMutex.Unlock()
	fake.ScheduleBuildStub = stub
}

func (fake *FakeJob) ScheduleBuildArgsForCall(i int) db.Build {
	fake.scheduleBuildMutex.RLock()
	defer fake.scheduleBuildMutex.RUnlock()
	argsForCall := fake.scheduleBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) ScheduleBuildReturns(result1 bool, result2 error) {
	fake.scheduleBuildMutex.Lock()
	defer fake.scheduleBuildMutex.Unlock()
	fake.ScheduleBuildStub = nil
	fake.scheduleBuildReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) ScheduleBuildReturnsOnCall(i int, result1 bool, result2 error) {
	fake.scheduleBuildMutex.Lock()
	defer fake.scheduleBuildMutex.Unlock()
	fake.ScheduleBuildStub = nil
	if fake.scheduleBuildReturnsOnCall == nil {
		fake.scheduleBuildReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.scheduleBuildReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) ScheduleRequestedTime() time.Time {
	fake.scheduleRequestedTimeMutex.Lock()
	ret, specificReturn := fake.scheduleRequestedTimeReturnsOnCall[len(fake.scheduleRequestedTimeArgsForCall)]
	fake.scheduleRequestedTimeArgsForCall = append(fake.scheduleRequestedTimeArgsForCall, struct {
	}{})
	fake.recordInvocation("ScheduleRequestedTime", []interface{}{})
	fake.scheduleRequestedTimeMutex.Unlock()
	if fake.ScheduleRequestedTimeStub != nil {
		return fake.ScheduleRequestedTimeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.scheduleRequestedTimeReturns
	return fakeReturns.result1
}

func (fake *FakeJob) ScheduleRequestedTimeCallCount() int {
	fake.scheduleRequestedTimeMutex.RLock()
	defer fake.scheduleRequestedTimeMutex.RUnlock()
	return len(fake.scheduleRequestedTimeArgsForCall)
}

func (fake *FakeJob) ScheduleRequestedTimeCalls(stub func() time.Time) {
	fake.scheduleRequestedTimeMutex.Lock()
	defer fake.scheduleRequestedTimeMutex.Unlock()
	fake.ScheduleRequestedTimeStub = stub
}

func (fake *FakeJob) ScheduleRequestedTimeReturns(result1 time.Time) {
	fake.scheduleRequestedTimeMutex.Lock()
	defer fake.scheduleRequestedTimeMutex.Unlock()
	fake.ScheduleRequestedTimeStub = nil
	fake.scheduleRequestedTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeJob) ScheduleRequestedTimeReturnsOnCall(i int, result1 time.Time) {
	fake.scheduleRequestedTimeMutex.Lock()
	defer fake.scheduleRequestedTimeMutex.Unlock()
	fake.ScheduleRequestedTimeStub = nil
	if fake.scheduleRequestedTimeReturnsOnCall == nil {
		fake.scheduleRequestedTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.scheduleRequestedTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeJob) SetHasNewInputs(arg1 bool) error {
	fake.setHasNewInputsMutex.Lock()
	ret, specificReturn := fake.setHasNewInputsReturnsOnCall[len(fake.setHasNewInputsArgsForCall)]
	fake.setHasNewInputsArgsForCall = append(fake.setHasNewInputsArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetHasNewInputs", []interface{}{arg1})
	fake.setHasNewInputsMutex.Unlock()
	if fake.SetHasNewInputsStub != nil {
		return fake.SetHasNewInputsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setHasNewInputsReturns
	return fakeReturns.result1
}

func (fake *FakeJob) SetHasNewInputsCallCount() int {
	fake.setHasNewInputsMutex.RLock()
	defer fake.setHasNewInputsMutex.RUnlock()
	return len(fake.setHasNewInputsArgsForCall)
}

func (fake *FakeJob) SetHasNewInputsCalls(stub func(bool) error) {
	fake.setHasNewInputsMutex.Lock()
	defer fake.setHasNewInputsMutex.Unlock()
	fake.SetHasNewInputsStub = stub
}

func (fake *FakeJob) SetHasNewInputsArgsForCall(i int) bool {
	fake.setHasNewInputsMutex.RLock()
	defer fake.setHasNewInputsMutex.RUnlock()
	argsForCall := fake.setHasNewInputsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) SetHasNewInputsReturns(result1 error) {
	fake.setHasNewInputsMutex.Lock()
	defer fake.setHasNewInputsMutex.Unlock()
	fake.SetHasNewInputsStub = nil
	fake.setHasNewInputsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) SetHasNewInputsReturnsOnCall(i int, result1 error) {
	fake.setHasNewInputsMutex.Lock()
	defer fake.setHasNewInputsMutex.Unlock()
	fake.SetHasNewInputsStub = nil
	if fake.setHasNewInputsReturnsOnCall == nil {
		fake.setHasNewInputsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setHasNewInputsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) Tags() []string {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if fake.TagsStub != nil {
		return fake.TagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tagsReturns
	return fakeReturns.result1
}

func (fake *FakeJob) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeJob) TagsCalls(stub func() []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeJob) TagsReturns(result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeJob) TagsReturnsOnCall(i int, result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeJob) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeJob) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeJob) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamNameReturns
	return fakeReturns.result1
}

func (fake *FakeJob) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeJob) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeJob) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) TransitionBuildID() int {
	fake.transitionBuildIDMutex.Lock()
	ret, specificReturn := fake.transitionBuildIDReturnsOnCall[len(fake.transitionBuildIDArgsForCall)]
	fake.transitionBuildIDArgsForCall = append(fake.transitionBuildIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TransitionBuildID", []interface{}{})
	fake.transitionBuildIDMutex.Unlock()
	if fake.TransitionBuildIDStub != nil {
		return fake.TransitionBuildIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.transitionBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) TransitionBuildIDCallCount() int {
	fake.transitionBuildIDMutex.RLock()
	defer fake.transitionBuildIDMutex.RUnlock()
	return len(fake.transitionBuildIDArgsForCall)
}

func (fake *FakeJob) TransitionBuildIDCalls(stub func() int) {
	fake.transitionBuildIDMutex.Lock()
	defer fake.transitionBuildIDMutex.Unlock()
	fake.TransitionBuildIDStub = stub
}

func (fake *FakeJob) TransitionBuildIDReturns(result1 int) {
	fake.transitionBuildIDMutex.Lock()
	defer fake.transitionBuildIDMutex.Unlock()
	fake.TransitionBuildIDStub = nil
	fake.transitionBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) TransitionBuildIDReturnsOnCall(i int, result1 int) {
	fake.transitionBuildIDMutex.Lock()
	defer fake.transitionBuildIDMutex.Unlock()
	fake.TransitionBuildIDStub = nil
	if fake.transitionBuildIDReturnsOnCall == nil {
		fake.transitionBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.transitionBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unpauseReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakeJob) UnpauseCalls(stub func() error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = stub
}

func (fake *FakeJob) UnpauseReturns(result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UnpauseReturnsOnCall(i int, result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateFirstLoggedBuildID(arg1 int) error {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	ret, specificReturn := fake.updateFirstLoggedBuildIDReturnsOnCall[len(fake.updateFirstLoggedBuildIDArgsForCall)]
	fake.updateFirstLoggedBuildIDArgsForCall = append(fake.updateFirstLoggedBuildIDArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("UpdateFirstLoggedBuildID", []interface{}{arg1})
	fake.updateFirstLoggedBuildIDMutex.Unlock()
	if fake.UpdateFirstLoggedBuildIDStub != nil {
		return fake.UpdateFirstLoggedBuildIDStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateFirstLoggedBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDCallCount() int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return len(fake.updateFirstLoggedBuildIDArgsForCall)
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDCalls(stub func(int) error) {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	defer fake.updateFirstLoggedBuildIDMutex.Unlock()
	fake.UpdateFirstLoggedBuildIDStub = stub
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDArgsForCall(i int) int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	argsForCall := fake.updateFirstLoggedBuildIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDReturns(result1 error) {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	defer fake.updateFirstLoggedBuildIDMutex.Unlock()
	fake.UpdateFirstLoggedBuildIDStub = nil
	fake.updateFirstLoggedBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDReturnsOnCall(i int, result1 error) {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	defer fake.updateFirstLoggedBuildIDMutex.Unlock()
	fake.UpdateFirstLoggedBuildIDStub = nil
	if fake.updateFirstLoggedBuildIDReturnsOnCall == nil {
		fake.updateFirstLoggedBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateFirstLoggedBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateLastScheduled(arg1 time.Time) error {
	fake.updateLastScheduledMutex.Lock()
	ret, specificReturn := fake.updateLastScheduledReturnsOnCall[len(fake.updateLastScheduledArgsForCall)]
	fake.updateLastScheduledArgsForCall = append(fake.updateLastScheduledArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("UpdateLastScheduled", []interface{}{arg1})
	fake.updateLastScheduledMutex.Unlock()
	if fake.UpdateLastScheduledStub != nil {
		return fake.UpdateLastScheduledStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateLastScheduledReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UpdateLastScheduledCallCount() int {
	fake.updateLastScheduledMutex.RLock()
	defer fake.updateLastScheduledMutex.RUnlock()
	return len(fake.updateLastScheduledArgsForCall)
}

func (fake *FakeJob) UpdateLastScheduledCalls(stub func(time.Time) error) {
	fake.updateLastScheduledMutex.Lock()
	defer fake.updateLastScheduledMutex.Unlock()
	fake.UpdateLastScheduledStub = stub
}

func (fake *FakeJob) UpdateLastScheduledArgsForCall(i int) time.Time {
	fake.updateLastScheduledMutex.RLock()
	defer fake.updateLastScheduledMutex.RUnlock()
	argsForCall := fake.updateLastScheduledArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeJob) UpdateLastScheduledReturns(result1 error) {
	fake.updateLastScheduledMutex.Lock()
	defer fake.updateLastScheduledMutex.Unlock()
	fake.UpdateLastScheduledStub = nil
	fake.updateLastScheduledReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateLastScheduledReturnsOnCall(i int, result1 error) {
	fake.updateLastScheduledMutex.Lock()
	defer fake.updateLastScheduledMutex.Unlock()
	fake.UpdateLastScheduledStub = nil
	if fake.updateLastScheduledReturnsOnCall == nil {
		fake.updateLastScheduledReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLastScheduledReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateLatestCompletedBuildID(arg1 db.Tx, arg2 int) error {
	fake.updateLatestCompletedBuildIDMutex.Lock()
	ret, specificReturn := fake.updateLatestCompletedBuildIDReturnsOnCall[len(fake.updateLatestCompletedBuildIDArgsForCall)]
	fake.updateLatestCompletedBuildIDArgsForCall = append(fake.updateLatestCompletedBuildIDArgsForCall, struct {
		arg1 db.Tx
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("UpdateLatestCompletedBuildID", []interface{}{arg1, arg2})
	fake.updateLatestCompletedBuildIDMutex.Unlock()
	if fake.UpdateLatestCompletedBuildIDStub != nil {
		return fake.UpdateLatestCompletedBuildIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateLatestCompletedBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UpdateLatestCompletedBuildIDCallCount() int {
	fake.updateLatestCompletedBuildIDMutex.RLock()
	defer fake.updateLatestCompletedBuildIDMutex.RUnlock()
	return len(fake.updateLatestCompletedBuildIDArgsForCall)
}

func (fake *FakeJob) UpdateLatestCompletedBuildIDCalls(stub func(db.Tx, int) error) {
	fake.updateLatestCompletedBuildIDMutex.Lock()
	defer fake.updateLatestCompletedBuildIDMutex.Unlock()
	fake.UpdateLatestCompletedBuildIDStub = stub
}

func (fake *FakeJob) UpdateLatestCompletedBuildIDArgsForCall(i int) (db.Tx, int) {
	fake.updateLatestCompletedBuildIDMutex.RLock()
	defer fake.updateLatestCompletedBuildIDMutex.RUnlock()
	argsForCall := fake.updateLatestCompletedBuildIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJob) UpdateLatestCompletedBuildIDReturns(result1 error) {
	fake.updateLatestCompletedBuildIDMutex.Lock()
	defer fake.updateLatestCompletedBuildIDMutex.Unlock()
	fake.UpdateLatestCompletedBuildIDStub = nil
	fake.updateLatestCompletedBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateLatestCompletedBuildIDReturnsOnCall(i int, result1 error) {
	fake.updateLatestCompletedBuildIDMutex.Lock()
	defer fake.updateLatestCompletedBuildIDMutex.Unlock()
	fake.UpdateLatestCompletedBuildIDStub = nil
	if fake.updateLatestCompletedBuildIDReturnsOnCall == nil {
		fake.updateLatestCompletedBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLatestCompletedBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateNextBuildID(arg1 db.Tx, arg2 interface{}) error {
	fake.updateNextBuildIDMutex.Lock()
	ret, specificReturn := fake.updateNextBuildIDReturnsOnCall[len(fake.updateNextBuildIDArgsForCall)]
	fake.updateNextBuildIDArgsForCall = append(fake.updateNextBuildIDArgsForCall, struct {
		arg1 db.Tx
		arg2 interface{}
	}{arg1, arg2})
	fake.recordInvocation("UpdateNextBuildID", []interface{}{arg1, arg2})
	fake.updateNextBuildIDMutex.Unlock()
	if fake.UpdateNextBuildIDStub != nil {
		return fake.UpdateNextBuildIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateNextBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UpdateNextBuildIDCallCount() int {
	fake.updateNextBuildIDMutex.RLock()
	defer fake.updateNextBuildIDMutex.RUnlock()
	return len(fake.updateNextBuildIDArgsForCall)
}

func (fake *FakeJob) UpdateNextBuildIDCalls(stub func(db.Tx, interface{}) error) {
	fake.updateNextBuildIDMutex.Lock()
	defer fake.updateNextBuildIDMutex.Unlock()
	fake.UpdateNextBuildIDStub = stub
}

func (fake *FakeJob) UpdateNextBuildIDArgsForCall(i int) (db.Tx, interface{}) {
	fake.updateNextBuildIDMutex.RLock()
	defer fake.updateNextBuildIDMutex.RUnlock()
	argsForCall := fake.updateNextBuildIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJob) UpdateNextBuildIDReturns(result1 error) {
	fake.updateNextBuildIDMutex.Lock()
	defer fake.updateNextBuildIDMutex.Unlock()
	fake.UpdateNextBuildIDStub = nil
	fake.updateNextBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateNextBuildIDReturnsOnCall(i int, result1 error) {
	fake.updateNextBuildIDMutex.Lock()
	defer fake.updateNextBuildIDMutex.Unlock()
	fake.UpdateNextBuildIDStub = nil
	if fake.updateNextBuildIDReturnsOnCall == nil {
		fake.updateNextBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateNextBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateTransitionBuildID(arg1 db.Tx, arg2 int) error {
	fake.updateTransitionBuildIDMutex.Lock()
	ret, specificReturn := fake.updateTransitionBuildIDReturnsOnCall[len(fake.updateTransitionBuildIDArgsForCall)]
	fake.updateTransitionBuildIDArgsForCall = append(fake.updateTransitionBuildIDArgsForCall, struct {
		arg1 db.Tx
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("UpdateTransitionBuildID", []interface{}{arg1, arg2})
	fake.updateTransitionBuildIDMutex.Unlock()
	if fake.UpdateTransitionBuildIDStub != nil {
		return fake.UpdateTransitionBuildIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateTransitionBuildIDReturns
	return fakeReturns.result1
}

func (fake *FakeJob) UpdateTransitionBuildIDCallCount() int {
	fake.updateTransitionBuildIDMutex.RLock()
	defer fake.updateTransitionBuildIDMutex.RUnlock()
	return len(fake.updateTransitionBuildIDArgsForCall)
}

func (fake *FakeJob) UpdateTransitionBuildIDCalls(stub func(db.Tx, int) error) {
	fake.updateTransitionBuildIDMutex.Lock()
	defer fake.updateTransitionBuildIDMutex.Unlock()
	fake.UpdateTransitionBuildIDStub = stub
}

func (fake *FakeJob) UpdateTransitionBuildIDArgsForCall(i int) (db.Tx, int) {
	fake.updateTransitionBuildIDMutex.RLock()
	defer fake.updateTransitionBuildIDMutex.RUnlock()
	argsForCall := fake.updateTransitionBuildIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeJob) UpdateTransitionBuildIDReturns(result1 error) {
	fake.updateTransitionBuildIDMutex.Lock()
	defer fake.updateTransitionBuildIDMutex.Unlock()
	fake.UpdateTransitionBuildIDStub = nil
	fake.updateTransitionBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateTransitionBuildIDReturnsOnCall(i int, result1 error) {
	fake.updateTransitionBuildIDMutex.Lock()
	defer fake.updateTransitionBuildIDMutex.Unlock()
	fake.UpdateTransitionBuildIDStub = nil
	if fake.updateTransitionBuildIDReturnsOnCall == nil {
		fake.updateTransitionBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTransitionBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	fake.clearTaskCacheMutex.RLock()
	defer fake.clearTaskCacheMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.finishedAndNextBuildMutex.RLock()
	defer fake.finishedAndNextBuildMutex.RUnlock()
	fake.firstLoggedBuildIDMutex.RLock()
	defer fake.firstLoggedBuildIDMutex.RUnlock()
	fake.getFullNextBuildInputsMutex.RLock()
	defer fake.getFullNextBuildInputsMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.getPendingBuildsMutex.RLock()
	defer fake.getPendingBuildsMutex.RUnlock()
	fake.hasNewInputsMutex.RLock()
	defer fake.hasNewInputsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.latestCompletedBuildIDMutex.RLock()
	defer fake.latestCompletedBuildIDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.nextBuildIDMutex.RLock()
	defer fake.nextBuildIDMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.requestScheduleMutex.RLock()
	defer fake.requestScheduleMutex.RUnlock()
	fake.rerunBuildMutex.RLock()
	defer fake.rerunBuildMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.scheduleBuildMutex.RLock()
	defer fake.scheduleBuildMutex.RUnlock()
	fake.scheduleRequestedTimeMutex.RLock()
	defer fake.scheduleRequestedTimeMutex.RUnlock()
	fake.setHasNewInputsMutex.RLock()
	defer fake.setHasNewInputsMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.transitionBuildIDMutex.RLock()
	defer fake.transitionBuildIDMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	fake.updateLastScheduledMutex.RLock()
	defer fake.updateLastScheduledMutex.RUnlock()
	fake.updateLatestCompletedBuildIDMutex.RLock()
	defer fake.updateLatestCompletedBuildIDMutex.RUnlock()
	fake.updateNextBuildIDMutex.RLock()
	defer fake.updateNextBuildIDMutex.RUnlock()
	fake.updateTransitionBuildIDMutex.RLock()
	defer fake.updateTransitionBuildIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeJob) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Job = new(FakeJob)
